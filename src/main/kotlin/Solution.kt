/**
 * 1~5000 k : 현재 피로도
 * 1~8 dungeons : 각 던전별 [최소 필요 피로도,소모 피로도]
 * 1~1000 : 최소 필요 피로도,소모 피로도
 *
 * 하루에 한번씩 탐험이 가능
 * 이때, 최대 던전 수를 return
 * k = 2
 * (0,1) (1,0) 의 경우의 수 2! = 2
 * k = 3
 * ((0,1),2) ((1,0),2) ((1,2),0) ((2,1),0) ((0,2),1) ((2,0),1) 의 경우의 수 3! = 6
 * k = 4 일때 4! = 24
 * 0,1,2,3 0,1,3,2 1,0,2,3 1,0,3,2
 * 0,2,1,3 0,2,3,1 2,0,1,3 2,0,3,1
 * 0,3,1,2 0,3,2,1 3,0,1,2 3,0,2,1
 *
 *
 * 즉 순서를 고려하여 뽑으니까 순열이다.
 * p(n,k) = n(n-1)(n-2)...(n-(k-1))
 * 순열의 경우 재귀로 구현하면 시간복잡도가 크게 증가하니까 DP로 구현할려고한다.
 *
 * 그렇다면 저장해야할 값은.... k의 범위? 아니면 각 서로간의 인덱스들의 결과값들?
 * 동적으로 이동한 값들을 추가하여,그 값을 저장?
 * ex) 0,2,1 을 이동 했을떄 피로도 ==> <MutableList,Int> = ([0,2,1],40)
 *
 */


class Solution {
    fun solution(k: Int, dungeons: Array<IntArray>): Int {
        var answer: Int = -1
        var count = 0
        var maxCount = dungeons.size
        var maps = dungeons.map{it[0] to it[1]}
        //key: 인덱스 value : 배열값
        //배열값 저장할 변수 선언
        //반복문(k!)을 통해 값을 계산
        //이떄 피로도가 0이하 되지않도록 만약 0 이된다면 그 이전값만 저장
        //결과된 계산 값 인자중 첫번째 인자 size으로 가장 큰값을 찾고 answer 로 리턴
        return answer
    }
}

fun main(){

    var a = Solution()
    a.solution(80,arrayOf(intArrayOf(80,20),intArrayOf(50,40),intArrayOf(30,10)))//3
}